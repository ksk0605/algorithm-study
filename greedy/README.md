# Greedy : 탐욕법

그리디 알고리즘은 단순하지만 강력한 알고리즘으로 어떤 문제가 있을 때 단순 무식하게 현재 상황에서 당장 좋은 것만 고르는 방법을 사용하여 문제를 해결하는 알고리즘이다. 즉, 현재의 선택이 나중에 미칠 영향을 고려하지 않는다는 것이 특징이다. 

특징이라고 한다면 다른 여타 알고리즘과는 달리 정형화된 풀이 방법이 정해져 있지 않다. 문제를 만났을 때 문제의 목표만을 위한 가장 좋은 것만을 조건으로 두고 풀어도 상관없는지만 잘 확인한다면 대부분의 문제는 크게 복잡하지 않은 코드로 해결할 수 있다. 

그리디 알고리즘은 기준에 따라 좋은 것을 선택하는 알고리즘이므로 문제에서 '가장 큰 순서대로', '가장 작은 순서대로'와 같은 기준을 알게 모르게 제시해준다. 대체로 이 기준은 정렬 알고리즘을 사용했을 때 만족시킬 수 있으므로 그리디 알고리즘은 정렬과 함께 짝을 이뤄 출제되는 경우가 많다. 다음 예시를 보자. 

## 1931번 : 회의실 배정
```py 
from sys import stdin as sin

n = int(sin.readline())

meetings = []
for _ in range(n): 
    meetings.append(list(map(int, sin.readline().split())))

# 시작 시간이 가장 빠른, 끝나는 시간이 가장 빠른
meetings.sort(key = lambda x:x[0])
meetings.sort(key = lambda x:x[1])

print(meetings)

end = 0
cnt = 0
for meeting in meetings: 
    if meeting[0] >= end: 
        end = meeting[1]
        cnt += 1
print(cnt)
```
해당 문제는 언뜻보면 회의의 길이와 시작시간, 끝나는 시간을 모두 고려하여 매 회 반복문을 통해 적절한 회의 길이를 찾아야하는 복잡한 알고리즘으로 보인다. 그러나 문제를 좀더 간단하게 생각하면 사실 회의 길이는 중요하지 않다. 회의 시간이 가장 짧은 것은 끝나는 시간이 가장 빠르면 자동으로 보장되기 때문이다. 

따라서 해당 문제 당장 회의를 시작할 수 있는 회의 중에서 끝나는 시간이 가장 빠른 회의를 찾는 문제로 바뀌게 되고 위 두가지 조건을 매회 찾기보다는 key값을 통해 위 경우가 보장되도록 정렬하면 간단하게 해결된다.

## 그리디 알고리즘의 정당성 
그리디는 강력하지만 모든 문제에 적용할 수는 없다. 대부분의 문제는 오히려 그리디 알고리즘으로 풀 수 없을 가능성이 크다. 그리디 알고리즘의 해법을 떠올렸을 때에는 필수적으로 정당성을 검증해봐야한다. 

예를 들어 위 문제와 같은 경우는 가장 빠르게 시작할 수 있는 회의 중 가장 빠르게 끝나는 회의를 찾는 것이 다른 경우의 수를 고려하지 않아도 된다는 보장이 있다. 

> __*당장 최선의 선택이 최적의 해를 보장하는지 검증하자!*__