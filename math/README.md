# 수학 

## 아르토스테네스의 체
일반적으로 소수를 구하는 방법은 2부터 해당 숫자까지 하나씩 나눠보면서 나누어떨어지는게 있는지 검사하는 방식으로 구현하게 될 것 이다 .
```py
n=100

def isPrime(a):
  if(a<2):
    return False
  for i in range(2,a):
    if(a%i==0):
      return False
  return True

for i in range(n+1):
  if(isPrime(i)):
    print(i)
```
그러나 이 경우 시간 초과에 걸리는 경우가 많다. 이때 사용해야 하는 것이 __에라토스테네스의 체__ 이다. 

__'에라토스테네스의 체'__ 란 범위에서 합성수를 지우는 방식으로 소수를 찾는 방법이다. 
1. 1은 제거 
2. 지워지지 않은 수 중 제일 작은 2를 소수로 채택하고, 나머지 2의 배수를 모두 지운다. 
3. 지워지지 않은 수 중 제일 작은 3을 소수로 채택하고, 나머지 3의 배수를 모두 지운다. 
4. 지워지지 않은 수 중 제일 작은 5를 소수로 채택하고, 나머지 5의 배수를 모두 지운다. 
5. (반복)

![](../image/에라토스테네스의%20체.png)

이것을 파이썬 코드로 구현한다면 다음과 같다.
```py
n=1000
a = [False,False] + [True]*(n-1)
primes=[]

for i in range(2,n+1):
  if a[i]:
    primes.append(i)
    for j in range(2*i, n+1, i):
        a[j] = False
print(primes)

```
간단하게는 주어진 숫자의 제곱근까지만 검사하는 방법도 존재한다. (2 x 4 와 4 x 2는 같기 때문)

## 오일러의 피
![](../image/오일러의%20피%20함수.png)
이름대로 레온하르트 오일러가 정의한 함수다. n과 서로소인 n이하의 자연수의 개수를 구하는 특수함수이다. 

공식을 증명하는 것은 좀 복잡하지만 문제를 푸는 것은 쉽다.
1. n을 정한다.
2. n의 소인수를 구한다.(소인수를 p라 하자)
3. n에 (1 - 1/p)를 곱한다.

```py
n=int(input())
ans = n

for i in range(2, int(n**0.5)+1):
    # i로 나누어 떨어진다면
    if n % i == 0:
        # n이 가지고 있는 i의 개수 만큼 나눠주기
        while n % i == 0:   
            n //= i
        # 오일러 피 함수 
        ans *= (1-1/i)

# 자기 자신이 소수였던 경우
if n>1:
    ans *= (1-1/n)

print(int(ans))

```

## 유클리드 호제법
2개의 자연수 혹은 정식의 최대공약수를 구하는 알고리즘의 하나. 제수와 피제수가 서로 바뀌며 나누는 과정을 반복하며 최종적으로 원하는 숫자를 얻어낸다. 

가장 핵심은 __a와 b의 최대공약수는 a를 b로 나눈(단, a>b) 나머지인 r과 b의 최대공약수와 같다__ 는 성질. 위의 성질을 이용하여 b를 r로 나눈 나머지 r'을 구하고 다시 r을 r'으로 나누며 과정을 반복하다가 나머지가 0이 되었을때 나누는 수인 제수가 a와 b의 최대 공약수가 된다. 

예를 들어 78696과 19332의 최대공약수를 구하면,

    78696 ＝ 19332×4 ＋ 1368
    19332 ＝ 1368×14 ＋ 180
     1368 ＝ 180×7 ＋ 108
      180 ＝ 108×1 ＋ 72
      108 ＝ 72×1 ＋ 36
       72 ＝ 36×2 ＋ 0

36으로 나누었을때 나머지가 0이 나오므로 36이 78696과 19332의 최대공약수이다. 

### 증명 
자연수인 a와 b가 있을때 (a>=b)  
a = bq + r을 만족하는 유일한 정수 q,r이 존재하게 된다(0<=r<b). 

a와 b의 최대공약수를 d라고 하면 a = da', b = db'이 될 것이고 a'와 b'는 서로소가 된다. 

이때  
a = bq + r  
da' = db'q + r  
가 되므로 r은 d의 배수가 된다.  
이제 r = dp라고 하자. 이때 b'와 p가 서로소라면 b와 r의 최대공약수가 d가 된다. 

그럼 b'와 p가 서로소가 아니라고 가정해보자. b'과 p의 최대공약수가 d'라면 b' = d'b'', p = d'p' 이라할때 

a = bq + r  
da' = db'q + dp = dd'b''q + dd'p' = dd'(b''q+ p')  
a' = d'(b''q+p')  
가 되므로 a'는 d'의 배수이다. 
즉, a'과 b' 모두 d'의 배수가 되므로 a'과 b'이 서로소라는 가정에 모순이다.  

따라서 d' 이 서로소라는 가정에서 시작된 모순이므로 d'은 1, 곧 b와 r의 최대공약수는 d가된다. 

### 코드 
```py
def gcd(m,n):
    while n! = 0:
	    if m < n:
		    m, n = n, m
	    if n == 0:
		    return m
	    if m % n == 0:
		    return n

```

