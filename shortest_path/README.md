# 최단 경로 알고리즘 

## 벨만-포드

> 한 노드에서 다른 노드까지의 최단 거리를 구하는 알고리즘

* 모든 정점 사이의 최단 거리를 구하는 플로이드-와샬 알고리즘과 달리 한 정점으로 부터 다른 정점으로의 거리를 구한다. 
* 다익스트라의 단점이었던 음수간선에 대한 대응이 가능한 알고리즘. 
* 그러나 각 정점에 연결된 간선만 확인하는 다익스트라와 달리 매 반복마다 모든 정점을 확인하는 알고리즘의 특성상 속도가 더 느리다는 단점이 있다 (O(VE)). 
* 다익스트라, 벨만-포드 모두 동일한 결과를 내지만 다익스트라 알고리즘이 벨만-포드 알고리즘이 해결하는 문제 중 일부를 최적화하였다고 볼 수 있음. 

### 구현 방법
1. 출발 노드를 설정한다.
2. 최단 거리 테이블을 초기화한다.
3. 다음의 과정을 (V(=정점) - 1)번 반복한다.
    1. 모든 간선 E개를 하나씩 확인한다.
    2. 각 간선을 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.

* 만약 음수 간선 순환이 발생하는지 체크하고 싶다면 3번 과정을 한 번 더 수행한다. --> 이때 최단 거리 테이블이 갱신된다면 음수 간선 순환이 존재(무한으로 숫자가 작아질 수 있기 때문에).

### 코드
```py
def bellman(): 
    # 출발 노드 설정
    start_node = 1
    dists[start_node] = 0 

    # N - 1 번 반복
    for _ in range(2,city+1): 
        # 전체 간선에 대해서
        for edge in edges:
            start = edge[0]
            end = edge[1]
            weight = edge[2]
            if dists[start] != INF and dists[end] > dists[start] + weight:
                dists[end] = dists[start] + weight

```

## 플로이드-와샬
> 주어진 그래프에서 모든 정점 쌍 사이의 최단 거리를 구해주는 알고리즘

* 간선의 값이 음수여도 잘 동작하는 것이 특징
* 단, 음수간선이 포함된 싸이클이 있을 경우에는 사용불가능.

### 구현 방법 
1. 그래프를 저장한다. (이차원 배열)
2. 저장된 노드의 개수만큼 반복
3. 매 반복회수마다 해당 노드를 거쳐가는 거리와 거쳐가지 않았을 때의 거리를 비교하여 테이블을 수정한다.

> 포인트는 현재 테이블에 적힌 값을 불완전한 최단 거리로 생각하지 말고, 중간에 다른 정점을 거치지 않았을 때의 최단 거리라고 생각하기!

정점이 V개라고 할 때 총 V단계에 걸쳐 갱신이 이루어지고 각 k=1,2,3,…,V번째 단계마다 총 V^2개의 모든 경로 값과 비교하므로 시간복잡도는 O(V^3).

### 코드
```py
def floyd(): 
    for node in range(1, n+1): 
        for start in range(1,n+1): 
            for end in range(1,n+1): 
                if graph[start][end] > graph[start][node] + graph[node][end]:
                    graph[start][end] = graph[start][node] + graph[node][end]

```