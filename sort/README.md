# 정렬

## 정렬의 종류
### Selection Sort, 선택 정렬
배열의 길이만큼 반복하며 데이터 중 가장 작은 값의 데이터를 선택하여 앞으로 보내는 정렬.  

선택 정렬의 시간 복잡도는 O(N²)이며 Worst, Average, Best 모두 동일.

### Insertion Sort, 삽입 정렬
데이터를 순서대로 뽑아서 적절한 위치를 찾아 삽입함으로써 완성하는 정렬.  

삽입 정렬의 시간 복잡도는 O(N²)이며 Worst, Average는 동일하고 이미 정렬되어 있는 Best의 경우 O(N). 무조건 위치를 변경하는 선택 정렬과 시간 복잡도가 같지만 필요할 때에 삽입한다는 점에서 연산수가 적어지므로 효율적. 이미 정렬되어 있는 데이터가 많다면 빠른 알고리즘.

### Bubble Sort, 버블 정렬
버블 정렬은 버블이 수면 위를 올라오는 듯 옆에 있는 데이터와 비교하여 더 작은 값을 앞으로 보내는 정렬.  

버블 정렬의 시간 복잡도는 O(N²)이며 Worst, Average, Best 모두 동일. 앞서 소개한 선택 정렬, 삽입 정렬과 시간 복잡도가 같지만 연산 수가 많아 정렬 알고리즘 중에서 가장 느리고 효율성이 떨어지는 정렬 방식.

### Merge Sort, 합병 정렬(또는 병합 정렬)
합병 정렬은 비교 기반 알고리즘으로 '분할, 정렬, 결합'순으로 진행되는데 데이터 배열을 2개 이상의 부분 배열로 분할하고 부분 배열에서 정렬을 한 뒤 결합하며 정렬을 수행.

합병 정렬의 시간 복잡도는 O(N ㏒ N)이며 Worst, Average, Best 모두 동일합니다. 데이터를 정확히 반으로 나누고 정렬하기 때문에 항상 일정한 시간 복잡도를 유지하므로 퀵 정렬의 한계점을 보완할 수 있는 장점이 있지만 다른 알고리즘과 비교했을 때 O(n) 수준의 메모리가 추가로 필요하다는 단점이 있음.

힙 정렬의 시간 복잡도는 O(N ㏒ N)이며 Worst, Average, Best 모두 동일. 완전 이진트리를 사용.

### Quick Sort, 퀵 정렬
퀵 정렬은 데이터 중 임의의 기준값을 정해서 두 부분 집합으로 나눔. 이때의 기준 값을 피벗(Pivot)이라고 하고 왼쪽은 피벗보다 작은 값, 오른쪽은 피벗보다 큰 값을 배치하고 더 이상 집합을 나눌 수 없을 때까지 재귀적으로 실행.

퀵 정렬의 시간 복잡도는 O(N ㏒ N)이며 Average, Best는 동일하고 Worst의 경우 O(N²). 삽입 정렬과 반대로 퀵 정렬은 이미 정렬된 데이터라면 매우 비효율적으로 작용.

### Heap Sort, 힙 정렬 

힙 정렬은 이진트리 기반의 트리형 자료구조로써 최솟값이나 최댓값을 찾아내기 위해서 사용. 내림차순 정렬을 위해서는 최대 힙, 오름차순 정렬을 위해서는 최소 힙을 구성하면 됨.

## 생각해볼 점
> 그럼 퀵 정렬은 언제나 가장 빠른가? NO

퀵정렬은 가장 빠른 알고리즘 중 하나지만 이미 정렬된 데이터의 경우 퀵 정렬보다 삽입 정렬을 사용하는 것이 더 빠르고 효율적임. 이처럼 상황에 따라 효율적인 알고리즘은 다르다는 것이 핵심.

"A 알고리즘과 B 알고리즘의 시간복잡도를 비교해주세요"  
"A 알고리즘은 최소 aa 최대 bb 이며 B 알고리즘은 최소 cc 최대 dd입니다"   
"그럼 A 알고리즘은 언제나 B 알고리즘보다 빠를까요?"  
"아닙니다. 데이터의 개수에 따라서 다릅니다."   
"그럼 n개의 데이터를 가진 프로그램이 있다고 가정해봅시다. 어떤 알고리즘을 사용하는게 좋을까요"   
"데이터의 개수가 크므로 A 알고리즘을 사용하겠습니다."   
"~~한 경우는 어떻게 할까요."   
"그럼 데이터에 한계치를 두어 x이하는 B알고리즘을, 이상은 A알고리즘을 사용하겠습니다"  